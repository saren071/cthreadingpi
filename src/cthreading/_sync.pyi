from __future__ import annotations

from types import TracebackType
from typing import Any, Callable

class Lock:
    def __init__(self) -> None: ...
    def acquire(self, blocking: bool = True, timeout: float = -1.0) -> bool: ...
    def release(self) -> None: ...
    def locked(self) -> bool: ...
    def __enter__(self) -> Lock: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -> None: ...
    def stats(self) -> dict[str, int]: ...

class RLock:
    def __init__(self) -> None: ...
    def acquire(self, blocking: bool = True, timeout: float = -1.0) -> bool: ...
    def release(self) -> None: ...
    def __enter__(self) -> RLock: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -> None: ...
    def stats(self) -> dict[str, int]: ...

class Event:
    def __init__(self) -> None: ...
    def is_set(self) -> bool: ...
    def check(self) -> bool: ...
    def set(self) -> None: ...
    def clear(self) -> None: ...
    def wait(self, timeout: float = -1.0) -> bool: ...

class Semaphore:
    def __init__(self, value: int = 1, max_value: int = 0) -> None: ...
    def acquire(self, blocking: bool = True, timeout: float = -1.0) -> bool: ...
    def release(self, n: int = 1) -> None: ...
    def __enter__(self) -> Semaphore: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -> None: ...
    def stats(self) -> dict[str, int]: ...

class BoundedSemaphore:
    def __init__(self, value: int = 1) -> None: ...
    def acquire(self, blocking: bool = True, timeout: float = -1.0) -> bool: ...
    def release(self, n: int = 1) -> None: ...
    def __enter__(self) -> BoundedSemaphore: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -> None: ...
    def stats(self) -> dict[str, int]: ...

class Condition:
    def __init__(self, lock: Lock | RLock | None = None) -> None: ...
    def acquire(self, *args: Any, **kwargs: Any) -> bool: ...
    def release(self) -> None: ...
    def wait(self, timeout: float = -1.0) -> bool: ...
    def wait_for(self, predicate: Callable[[], bool], timeout: float = -1.0) -> bool: ...
    def notify(self, n: int = 1) -> None: ...
    def notify_all(self) -> None: ...
    def __enter__(self) -> Condition: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -> None: ...

class BrokenBarrierError(RuntimeError): ...

class Barrier:
    def __init__(self, parties: int, action: Callable[[], None] | None = None, timeout: float | None = None) -> None: ...
    def wait(self, timeout: float | None = None) -> int: ...
    def reset(self) -> None: ...
    def abort(self) -> None: ...
    @property
    def parties(self) -> int: ...
    @property
    def n_waiting(self) -> int: ...
    @property
    def broken(self) -> bool: ...
